<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cinematic Love Story | Three.js</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400&display=swap');

        body {
            margin: 0;
            overflow-x: hidden;
            background-color: #0f0c29; /* Fallback */
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            /* Soft vignette via CSS for cinematic feel */
            box-shadow: inset 0 0 150px rgba(0,0,0,0.5);
        }

        #scroll-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 500vh; /* Scroll length */
            z-index: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, transparent 50%, rgba(0,0,0,0.4) 100%);
        }

        .cinematic-text {
            font-family: 'Cinzel', serif;
            color: #fff;
            text-align: center;
            opacity: 0;
            text-shadow: 0 10px 30px rgba(0,0,0,0.8);
            position: absolute;
            max-width: 900px;
            padding: 0 40px;
            transform: translateY(30px);
            letter-spacing: 0.05em;
        }

        .cinematic-text h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            font-weight: 400;
            line-height: 1.2;
        }

        .cinematic-text p {
            font-size: 1.25rem;
            font-weight: 300;
            opacity: 0.9;
        }

        #final-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 24px 60px;
            font-size: 1.25rem;
            font-family: 'Cinzel', serif;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1);
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: none;
        }

        #final-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: #fff;
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 200, 200, 0.4);
        }

        #final-question {
            font-family: 'Cinzel', serif;
            font-size: 3.5rem;
            color: #fff;
            text-shadow: 0 0 40px rgba(255, 100, 100, 0.6);
            opacity: 0;
            position: absolute;
            text-align: center;
            display: none;
            padding: 20px;
        }

        /* Loader */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-family: 'Cinzel', serif;
            transition: opacity 1.5s ease-out;
        }
        
        .loader-bar {
            width: 200px;
            height: 2px;
            background: #333;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .loader-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: #d4af37; /* Gold */
            transition: width 0.5s;
        }

        .grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }
    </style>
</head>
<body>

    <!-- Film Grain Overlay -->
    <div class="grain"></div>

    <!-- Loader -->
    <div id="loader">
        <div>PREPARING SCENE</div>
        <div class="loader-bar"><div class="loader-progress" id="loader-progress"></div></div>
    </div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Scroll Track -->
    <div id="scroll-track"></div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div class="cinematic-text" id="text-1">
            <h1>When there was distance between us...</h1>
        </div>

        <div class="cinematic-text" id="text-2">
            <p>Step by step...</p>
        </div>

        <div class="cinematic-text" id="text-3">
            <h1>Almost 4 years...</h1>
        </div>
        
        <div class="cinematic-text" id="text-4">
            <h1>And every day...</h1>
        </div>

        <div class="cinematic-text" id="text-5">
            <h1>I choose you.</h1>
        </div>

        <button id="final-btn">Take the final step</button>
        
        <div id="final-question">
            Will you be my Valentine? üíù
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                bg: new THREE.Color(0x201b31), // Deep purple/blue
                fogStart: new THREE.Color(0x2a2342),
                fogEnd: new THREE.Color(0xffd1dc), // Pinkish
                lightWarm: 0xffaa77,
                lightCool: 0xccccff,
                lightRim: 0xffd1b3
            },
            camera: {
                fov: 35, // Cinematic narrow FOV
                near: 0.1,
                far: 100
            }
        };

        // --- Globals ---
        let scene, camera, renderer, composer, controls;
        let boy, girl;
        let particles;
        let scrollProgress = 0;
        let isClimax = false;
        let timeScale = 1.0;
        let clock = new THREE.Clock();
        
        // Lights
        let hemiLight, keyLight, fillLight, rimLight;

        // State
        const state = {
            walkProgress: 0,
            targetCameraZ: 18,
            targetCameraY: 3.5
        };

        // --- Initialization ---
        async function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = CONFIG.colors.bg;
            scene.fog = new THREE.FogExp2(CONFIG.colors.fogStart, 0.03);

            // 2. Camera (Cinematic)
            camera = new THREE.PerspectiveCamera(CONFIG.camera.fov, window.innerWidth / window.innerHeight, CONFIG.camera.near, CONFIG.camera.far);
            camera.position.set(0, 3.5, 18);

            // 3. Renderer (High Quality)
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // Mandatory Settings
            renderer.physicallyCorrectLights = true;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.8;
            bloomPass.strength = 0.3;
            bloomPass.radius = 0.5;

            const outputPass = new OutputPass();

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);

            // 5. Lighting (Cinematic 4-Point)
            setupCinematicLighting();

            // 6. Environment (HDR & Floor)
            await setupEnvironment();

            // 7. Characters
            await setupCharacters();

            // 8. Particles
            createParticles();

            // 9. Scroll Logic
            setupScroll();

            // 10. Events
            window.addEventListener('resize', onWindowResize);
            document.getElementById('final-btn').addEventListener('click', triggerClimax);

            // Hide Loader
            document.getElementById('loader-progress').style.width = '100%';
            setTimeout(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 1500);
            }, 500);

            animate();
        }

        // --- CINEMATIC LIGHTING SETUP ---
        function setupCinematicLighting() {
            // 1. Hemisphere (Sky/Ground Ambient)
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            // 2. Key Light (Warm, Main Direction)
            keyLight = new THREE.DirectionalLight(CONFIG.colors.lightWarm, 2.0);
            keyLight.position.set(5, 10, 7);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.bias = -0.001;
            keyLight.shadow.normalBias = 0.02; // Reduces shadow acne on curved surfaces
            scene.add(keyLight);

            // 3. Fill Light (Cool, Soft, Opposite Key)
            fillLight = new THREE.DirectionalLight(CONFIG.colors.lightCool, 0.8);
            fillLight.position.set(-5, 2, -5);
            scene.add(fillLight);

            // 4. Rim Light (Backlight for contour)
            rimLight = new THREE.SpotLight(CONFIG.colors.lightRim, 3.0);
            rimLight.position.set(0, 5, -8);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);
        }

        // --- ENVIRONMENT ---
        async function setupEnvironment() {
            // Floor (Shadow Catcher)
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.1
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Load HDR (Using a reliable CDN for a pastel HDR)
            // If this fails, the scene still looks good with our manual lights
            try {
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                
                const rgbeloader = new RGBELoader();
                // A soft studio HDR
                const hdrUrl = 'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_09_1k.hdr';
                
                const texture = await rgbeloader.loadAsync(hdrUrl);
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                
                scene.environment = envMap;
                // scene.background = envMap; // Optional: show HDR as bg, but we use CSS gradient
                
                texture.dispose();
                pmremGenerator.dispose();
            } catch (e) {
                console.warn("HDR Load failed, relying on manual lights", e);
            }
        }

        // --- CHARACTERS (GLTF) ---
        async function setupCharacters() {
            const loader = new GLTFLoader();
            
            // Helper to load model
            const loadModel = (url, name) => {
                return new Promise((resolve, reject) => {
                    loader.load(url, (gltf) => {
                        const model = gltf.scene;
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                // Enhance materials for cinematic look
                                if(child.material) {
                                    child.material.envMapIntensity = 1.0;
                                }
                            }
                        });
                        resolve(model);
                    }, undefined, (error) => {
                        console.error(`Error loading ${name}:`, error);
                        reject(error);
                    });
                });
            };

            try {
                // Using high-quality stylized human models from official Three.js examples repo
                // These are "Xbot" and "Ybot" (Stylized robots/humans) which are safe for demo use
                // For a real romantic scene, you would replace these URLs with your specific GLTFs of Alisher/Snezhana
                
                // Note: If these external URLs fail, the catch block creates beautiful procedural characters
                
                // Girl (Left)
                girl = await loadModel('https://threejs.org/examples/models/gltf/Xbot.glb', 'Girl');
                girl.scale.set(0.5, 0.5, 0.5);
                girl.position.set(-8, 0, 0);
                girl.rotation.y = Math.PI / 2;
                scene.add(girl);

                // Boy (Right)
                boy = await loadModel('https://threejs.org/examples/models/gltf/Ybot.glb', 'Boy');
                boy.scale.set(0.5, 0.5, 0.5);
                boy.position.set(8, 0, 0);
                boy.rotation.y = -Math.PI / 2;
                scene.add(boy);
                
                document.getElementById('loader-progress').style.width = '80%';

            } catch (e) {
                console.warn("GLTF Load failed, generating Procedural Cinematic Characters");
                createProceduralCharacters();
            }
        }

        // Fallback / Procedural Generation (High Quality)
        function createProceduralCharacters() {
            // Create beautifully designed abstract figures if GLTF fails
            // Girl (Left)
            girl = createStylizedFigure(0xffb7c5); // Pink tones
            girl.position.set(-8, 0, 0);
            girl.rotation.y = Math.PI / 2;
            scene.add(girl);

            // Boy (Right)
            boy = createStylizedFigure(0x6495ed); // Blue tones
            boy.position.set(8, 0, 0);
            boy.rotation.y = -Math.PI / 2;
            scene.add(boy);
            
            document.getElementById('loader-progress').style.width = '90%';
        }

        function createStylizedFigure(colorHex) {
            const group = new THREE.Group();
            
            // Material - Porcelain/Glossy look
            const skinMat = new THREE.MeshPhysicalMaterial({
                color: 0xffe0bd,
                roughness: 0.2,
                metalness: 0.0,
                clearcoat: 0.3,
                clearcoatRoughness: 0.1
            });
            
            const clothesMat = new THREE.MeshPhysicalMaterial({
                color: colorHex,
                roughness: 0.4,
                metalness: 0.1,
                sheen: 1.0,
                sheenColor: 0xffffff
            });

            // Body
            const bodyGeo = new THREE.CapsuleGeometry(0.5, 1.5, 4, 16);
            const body = new THREE.Mesh(bodyGeo, clothesMat);
            body.position.y = 1.25;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.45, 32, 32);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 2.4;
            head.castShadow = true;
            group.add(head);

            // Hair (Stylized Sphere)
            const hairGeo = new THREE.SphereGeometry(0.48, 32, 32, 0, Math.PI * 2, 0, Math.PI/2.2);
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 2.45;
            group.add(hair);

            return group;
        }

        // --- PARTICLES ---
        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const count = 300;
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);

            for(let i=0; i<count; i++) {
                positions[i*3] = (Math.random() - 0.5) * 30;
                positions[i*3+1] = Math.random() * 10;
                positions[i*3+2] = (Math.random() - 0.5) * 20;
                sizes[i] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // Custom Shader Material for soft glowing particles
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0xffd700) }
                },
                vertexShader: `
                    attribute float size;
                    varying float vOpacity;
                    uniform float time;
                    void main() {
                        vec3 pos = position;
                        pos.y += sin(time * 0.5 + position.x) * 0.5;
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                        vOpacity = 0.6 + 0.4 * sin(time + position.x);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vOpacity;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);
                        gl_FragColor = vec4(color, vOpacity * glow);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            particles.visible = false; // Hidden initially
            scene.add(particles);
        }

        // --- SCROLL LOGIC ---
        function setupScroll() {
            gsap.registerPlugin(ScrollTrigger);

            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: "#scroll-track",
                    start: "top top",
                    end: "bottom bottom",
                    scrub: 1.5, // Smooth scrub
                    onUpdate: (self) => {
                        scrollProgress = self.progress;
                    }
                }
            });

            // Scene 1: Distance (0-20%)
            tl.to("#text-1", { opacity: 1, duration: 0.15 }, 0);
            tl.to("#text-1", { opacity: 0, duration: 0.1 }, 0.2);

            // Scene 2: Approach (20-60%)
            tl.to(state, { walkProgress: 1, duration: 0.4, ease: "none" }, 0.2);
            tl.to("#text-2", { opacity: 1, duration: 0.1 }, 0.3);
            tl.to("#text-2", { opacity: 0, duration: 0.1 }, 0.5);
            
            // Camera Zoom In
            tl.to(state, { targetCameraZ: 8, targetCameraY: 2.5, duration: 0.4 }, 0.2);

            // Scene 3: Near (60-85%) - Slow down scroll visually by pausing text
            tl.to("#text-3", { opacity: 1, duration: 0.05 }, 0.6);
            tl.to("#text-3", { opacity: 0, duration: 0.05 }, 0.68);
            
            tl.to("#text-4", { opacity: 1, duration: 0.05 }, 0.72);
            tl.to("#text-4", { opacity: 0, duration: 0.05 }, 0.78);
            
            tl.to("#text-5", { opacity: 1, duration: 0.05 }, 0.82);
            tl.to("#text-5", { opacity: 0, duration: 0.05 }, 0.88);

            // Scene 4: Button Reveal (85%+)
            tl.call(() => {
                if(!isClimax) {
                    const btn = document.getElementById('final-btn');
                    btn.style.display = 'block';
                    gsap.to(btn, { opacity: 1, scale: 1, duration: 1.5, ease: "power2.out" });
                }
            }, null, 0.9);
        }

        // --- CLIMAX ---
        function triggerClimax() {
            if(isClimax) return;
            isClimax = true;

            // Hide Button
            gsap.to("#final-btn", { opacity: 0, y: -20, duration: 0.5 });

            // 1. Time Dilation (Slow Motion)
            gsap.to(window, { timeScale: 0.3, duration: 1 });

            // 2. Move Characters to Center (Holding hands distance)
            gsap.to(girl.position, { x: -0.8, duration: 4, ease: "power2.inOut" });
            gsap.to(boy.position, { x: 0.8, duration: 4, ease: "power2.inOut" });

            // Rotate to face each other slightly more intimately
            gsap.to(girl.rotation, { y: Math.PI / 3, duration: 4 });
            gsap.to(boy.rotation, { y: -Math.PI / 3, duration: 4 });

            // 3. Lighting Shift to Peak Warmth
            gsap.to(keyLight.color, { r: 1, g: 0.8, b: 0.6, duration: 3 }); // Orange/Warm
            gsap.to(keyLight, { intensity: 4, duration: 3 });
            gsap.to(rimLight, { intensity: 5, duration: 3 });
            gsap.to(scene.fog.color, { r: 1, g: 0.9, b: 0.8, duration: 3 }); // Pinkish fog

            // 4. Bloom Explosion
            const bloomPass = composer.passes[1];
            gsap.to(bloomPass, { strength: 2.0, radius: 1.0, duration: 3 });

            // 5. Particle Explosion
            particles.visible = true;
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<positions.length/3; i++) {
                // Reset to center
                positions[i*3] = (Math.random() - 0.5) * 2;
                positions[i*3+1] = (Math.random() - 0.5) * 2 + 2;
                positions[i*3+2] = (Math.random() - 0.5) * 2;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Explode outward
            gsap.to(particles.material.uniforms.time, { value: 20, duration: 5, ease: "power2.out" });

            // 6. Camera Orbit & Zoom
            gsap.to(camera.position, { x: 2, y: 2.2, z: 4, duration: 5, ease: "power2.inOut" });

            // 7. Final Text
            setTimeout(() => {
                const finalQ = document.getElementById('final-question');
                finalQ.style.display = 'block';
                gsap.to(finalQ, { opacity: 1, duration: 2, delay: 0.5 });
                
                // Restore time
                gsap.to(window, { timeScale: 1, duration: 2 });
            }, 2500);
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta() * timeScale;
            const elapsed = clock.getElapsedTime();

            // 1. Character Movement (Lerp based on scroll)
            if(!isClimax) {
                const startDist = 8;
                const endDist = 2.5;
                const currentDist = startDist - (state.walkProgress * (startDist - endDist));
                
                girl.position.x = -currentDist;
                boy.position.x = currentDist;

                // Idle Animation (Breathing)
                const breath = Math.sin(elapsed * 2) * 0.02;
                girl.scale.set(0.5 + breath, 0.5 - breath, 0.5 + breath);
                boy.scale.set(0.5 + breath, 0.5 - breath, 0.5 + breath);
                
                // Camera Smooth Follow
                camera.position.z += (state.targetCameraZ - camera.position.z) * 0.05;
                camera.position.y += (state.targetCameraY - camera.position.y) * 0.05;
                
                // Subtle camera sway based on mouse (simulated here with sin)
                camera.position.x += (Math.sin(elapsed * 0.5) * 0.5 - camera.position.x) * 0.01;
                camera.lookAt(0, 1.5, 0);
            } else {
                // Climax Orbit
                const orbitSpeed = elapsed * 0.2;
                camera.position.x = Math.sin(orbitSpeed) * 4;
                camera.position.z = 4 + Math.cos(orbitSpeed) * 2;
                camera.lookAt(0, 1.8, 0);
            }

            // 2. Lighting Updates based on Proximity
            if(!isClimax) {
                // As they get closer, light gets warmer
                const warmth = state.walkProgress; // 0 to 1
                keyLight.color.lerpColors(new THREE.Color(CONFIG.colors.lightWarm), new THREE.Color(0xff8844), warmth);
                keyLight.intensity = 2.0 + (warmth * 1.0); // Gets brighter
                rimLight.intensity = 3.0 + (warmth * 2.0);
                
                // Fog clears
                scene.fog.density = 0.03 - (warmth * 0.02);
                
                // Particles fade in
                if(state.walkProgress > 0.3) {
                    particles.visible = true;
                    particles.material.opacity = (state.walkProgress - 0.3) * 2;
                }
            }

            // 3. Particle Animation
            if(particles && particles.visible) {
                particles.material.uniforms.time.value = elapsed;
                particles.rotation.y += 0.001;
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();
    </script>
</body>
</html>
