<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Almost 4 Years — A Cinematic 3D Story</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Cormorant Garamond', 'Playfair Display', Georgia, serif;
            overflow-x: hidden;
            background: linear-gradient(180deg, #ffdde1 0%, #ee9ca7 50%, #d4a5a5 100%);
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }
        
        .scroll-container {
            position: relative;
            z-index: 10;
        }
        
        .scene-section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            pointer-events: none;
        }
        
        .text-overlay {
            text-align: center;
            color: #4a3f3f;
            text-shadow: 0 2px 20px rgba(255, 255, 255, 0.8);
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            padding: 2rem;
        }
        
        .text-overlay.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .text-overlay h1 {
            font-size: clamp(2rem, 5vw, 4rem);
            font-weight: 300;
            letter-spacing: 0.15em;
            margin-bottom: 1rem;
            line-height: 1.4;
        }
        
        .text-overlay h2 {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            font-weight: 300;
            letter-spacing: 0.1em;
            opacity: 0.9;
        }
        
        .text-overlay p {
            font-size: clamp(1.2rem, 2.5vw, 1.8rem);
            font-weight: 300;
            letter-spacing: 0.05em;
            margin-top: 1rem;
            font-style: italic;
        }
        
        .fade-line {
            height: 2px;
            width: 100px;
            background: linear-gradient(90deg, transparent, rgba(74, 63, 63, 0.4), transparent);
            margin: 2rem auto;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ffdde1 0%, #ee9ca7 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease;
        }
        
        .loading-text {
            font-size: 1.5rem;
            color: #4a3f3f;
            letter-spacing: 0.3em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loading-text">LOADING SCENE...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="scroll-container">
        <section class="scene-section" data-scene="0">
            <div class="text-overlay">
                <h1>Почти 4 года…</h1>
                <div class="fade-line"></div>
                <p>Scroll to begin the journey</p>
            </div>
        </section>

        <section class="scene-section" data-scene="1">
            <div class="text-overlay">
                <h2>Distance makes the heart</h2>
                <h2>grow fonder</h2>
            </div>
        </section>

        <section class="scene-section" data-scene="2">
            <div class="text-overlay">
                <h2>И я до сих пор…</h2>
                <div class="fade-line"></div>
                <p>Every step brings us closer</p>
            </div>
        </section>

        <section class="scene-section" data-scene="3">
            <div class="text-overlay">
                <h1>выбираю тебя.</h1>
                <div class="fade-line"></div>
                <p>Always. Forever.</p>
            </div>
        </section>
    </div>

    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=Playfair+Display:wght@300;400&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene setup
        const scene = new THREE.Scene();
        
        // Soft gradient fog for depth
        scene.fog = new THREE.FogExp2(0xffdde1, 0.02);
        scene.background = new THREE.Color(0xffdde1);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.5, 8);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        
        // Cinematic renderer settings
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyCorrectLights = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Post-processing for cinematic bloom
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.3, // strength
            0.4, // radius
            0.85 // threshold
        );
        composer.addPass(bloomPass);

        // Cinematic Lighting Setup
        // 1. Key Light - Warm, soft, from side
        const keyLight = new THREE.SpotLight(0xfff0e6, 80);
        keyLight.position.set(-5, 4, 5);
        keyLight.angle = Math.PI / 4;
        keyLight.penumbra = 0.5;
        keyLight.decay = 2;
        keyLight.distance = 50;
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        keyLight.shadow.bias = -0.0001;
        keyLight.shadow.radius = 4;
        scene.add(keyLight);

        // 2. Rim Light - Behind characters, brighter, separates from background
        const rimLight = new THREE.SpotLight(0xffffff, 60);
        rimLight.position.set(0, 3, -5);
        rimLight.angle = Math.PI / 3;
        rimLight.penumbra = 0.8;
        rimLight.decay = 2;
        rimLight.distance = 50;
        scene.add(rimLight);

        // 3. Fill Light - Subtle, cooler tone
        const fillLight = new THREE.DirectionalLight(0xe6f0ff, 2);
        fillLight.position.set(5, 2, 3);
        scene.add(fillLight);

        // 4. Ambient/Hemisphere for mood
        const hemiLight = new THREE.HemisphereLight(0xffd1dc, 0x8b7d8b, 0.6);
        scene.add(hemiLight);

        // Character placeholders (replace with glTF models)
        const tomGroup = new THREE.Group();
        const jerryGroup = new THREE.Group();

        // Create placeholder character meshes (stylized cute forms)
        function createPlaceholderCharacter(color, isTom) {
            const group = new THREE.Group();
            
            // Body - soft rounded form
            const bodyGeo = new THREE.SphereGeometry(0.6, 32, 32);
            bodyGeo.scale(1, 1.3, 0.8);
            const bodyMat = new THREE.MeshPhysicalMaterial({
                color: color,
                roughness: 0.4,
                metalness: 0.1,
                clearcoat: 0.3,
                clearcoatRoughness: 0.2
            });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;
            body.receiveShadow = true;
            group.add(body);

            // Head - larger, cute proportions
            const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
            const headMat = new THREE.MeshPhysicalMaterial({
                color: 0xffe4d6,
                roughness: 0.3,
                metalness: 0,
                subsurfaceScattering: true
            });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.8;
            head.castShadow = true;
            head.receiveShadow = true;
            group.add(head);

            // Eyes - big with glint
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshPhysicalMaterial({
                color: 0x2c3e50,
                roughness: 0.1,
                metalness: 0.1
            });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.15, 1.85, 0.4);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.15, 1.85, 0.4);
            group.add(rightEye);

            // Eye glints
            const glintGeo = new THREE.SphereGeometry(0.03, 8, 8);
            const glintMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            
            const leftGlint = new THREE.Mesh(glintGeo, glintMat);
            leftGlint.position.set(-0.12, 1.88, 0.48);
            group.add(leftGlint);
            
            const rightGlint = new THREE.Mesh(glintGeo, glintMat);
            rightGlint.position.set(0.18, 1.88, 0.48);
            group.add(rightGlint);

            // Soft hair (simplified as hemisphere)
            const hairGeo = new THREE.SphereGeometry(0.52, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const hairMat = new THREE.MeshPhysicalMaterial({
                color: isTom ? 0x3d2314 : 0x8b4513,
                roughness: 0.6,
                metalness: 0.1
            });
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 1.8;
            group.add(hair);

            return group;
        }

        // Create placeholder characters
        const tomPlaceholder = createPlaceholderCharacter(0x4a90e2, true);
        tomGroup.add(tomPlaceholder);
        tomGroup.position.set(-4, 0, 0);
        tomGroup.rotation.y = Math.PI / 6;
        scene.add(tomGroup);

        const jerryPlaceholder = createPlaceholderCharacter(0xe91e63, false);
        jerryGroup.add(jerryPlaceholder);
        jerryGroup.position.set(4, 0, 0);
        jerryGroup.rotation.y = -Math.PI / 6;
        scene.add(jerryGroup);

        // Frozen raindrops particles
        const rainCount = 200;
        const rainGeo = new THREE.BufferGeometry();
        const rainPositions = new Float32Array(rainCount * 3);
        const rainVelocities = [];

        for (let i = 0; i < rainCount; i++) {
            rainPositions[i * 3] = (Math.random() - 0.5) * 20;
            rainPositions[i * 3 + 1] = Math.random() * 10;
            rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            rainVelocities.push({
                y: -0.02 - Math.random() * 0.03,
                x: (Math.random() - 0.5) * 0.01,
                z: (Math.random() - 0.5) * 0.01
            });
        }

        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
        
        const rainMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        const rainSystem = new THREE.Points(rainGeo, rainMat);
        rainSystem.visible = false;
        scene.add(rainSystem);

        // Ground plane (invisible shadow catcher)
        const groundGeo = new THREE.PlaneGeometry(50, 50);
        const groundMat = new THREE.ShadowMaterial({ opacity: 0.1 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // Scroll state
        let scrollProgress = 0;
        let targetScrollProgress = 0;
        const sections = document.querySelectorAll('.scene-section');
        const textOverlays = document.querySelectorAll('.text-overlay');

        // Smooth scroll handling
        window.addEventListener('scroll', () => {
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            targetScrollProgress = window.scrollY / maxScroll;
        });

        // Intersection Observer for text animations
        const observerOptions = {
            threshold: 0.5,
            rootMargin: '0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelector('.text-overlay').classList.add('visible');
                } else {
                    entry.target.querySelector('.text-overlay').classList.remove('visible');
                }
            });
        }, observerOptions);

        sections.forEach(section => observer.observe(section));

        // Animation variables
        const clock = new THREE.Clock();
        let time = 0;

        // Character idle animation offsets
        const tomOffset = Math.random() * 100;
        const jerryOffset = Math.random() * 100;

        // Load glTF models (replace placeholders when available)
        const loader = new GLTFLoader();
        
        // Function to replace placeholder with actual model
        function loadCharacter(url, placeholder, position, rotation) {
            loader.load(url, (gltf) => {
                const model = gltf.scene;
                
                // Remove placeholder
                placeholder.parent.remove(placeholder);
                
                // Setup model
                model.position.copy(position);
                model.rotation.y = rotation;
                
                // Enable shadows
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.roughness = Math.max(child.material.roughness, 0.3);
                        }
                    }
                });
                
                // Add to scene
                scene.add(model);
                
                // Update reference
                if (placeholder === tomPlaceholder) {
                    tomGroup.clear();
                    tomGroup.add(model);
                } else {
                    jerryGroup.clear();
                    jerryGroup.add(model);
                }
            }, undefined, (error) => {
                console.log('Model load failed, using placeholder:', error);
            });
        }

        // Attempt to load models from Yandex (will fail without proper CORS/setup, placeholders remain)
        // Replace these URLs with your actual hosted model URLs
        // loadCharacter('path/to/tom.gltf', tomPlaceholder, new THREE.Vector3(-4, 0, 0), Math.PI / 6);
        // loadCharacter('path/to/jerry.gltf', jerryPlaceholder, new THREE.Vector3(4, 0, 0), -Math.PI / 6);

        // Hide loading screen
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 1500);

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            time += delta;

            // Smooth scroll interpolation
            scrollProgress += (targetScrollProgress - scrollProgress) * 0.05;

            // Scene phases based on scroll
            // Phase 0: Apart (0-0.33)
            // Phase 1: Moving closer (0.33-0.66)
            // Phase 2: Almost together (0.66-0.9)
            // Phase 3: Together/Climax (0.9-1.0)

            const phase = Math.min(scrollProgress * 3, 2.5); // 0 to 2.5 range
            
            // Character positions based on scroll
            const startDistance = 4;
            const endDistance = 0.8;
            const currentDistance = THREE.MathUtils.lerp(startDistance, endDistance, Math.min(phase / 2, 1));
            
            tomGroup.position.x = -currentDistance;
            jerryGroup.position.x = currentDistance;
            
            // Rotation - turn to face each other more as they get closer
            const lookAngle = THREE.MathUtils.lerp(Math.PI / 6, Math.PI / 2.5, Math.min(phase / 2, 1));
            tomGroup.rotation.y = lookAngle;
            jerryGroup.rotation.y = -lookAngle;

            // Camera movement - cinematic drift and zoom
            const zoomLevel = THREE.MathUtils.lerp(8, 3.5, Math.min(phase / 2, 1));
            camera.position.z = zoomLevel + Math.sin(time * 0.3) * 0.1; // subtle breathing
            
            // Camera orbit at climax
            if (phase > 2) {
                const orbitAngle = (phase - 2) * Math.PI * 0.5;
                camera.position.x = Math.sin(orbitAngle) * 2;
                camera.position.y = 1.5 + Math.cos(orbitAngle) * 0.5;
                camera.lookAt(0, 1, 0);
            } else {
                camera.position.x = Math.sin(time * 0.2) * 0.3;
                camera.position.y = 1.5 + Math.cos(time * 0.15) * 0.1;
                camera.lookAt(0, 1.2, 0);
            }

            // Lighting evolution - warmer as they get closer
            const warmth = Math.min(phase / 2, 1);
            keyLight.color.setHSL(0.08, 0.5 + warmth * 0.3, 0.94);
            keyLight.intensity = 80 + warmth * 40;
            
            // Rim light intensifies
            rimLight.intensity = 60 + warmth * 60;
            
            // Fill becomes warmer
            fillLight.color.setHSL(0.6 - warmth * 0.1, 0.3, 0.95);

            // Idle animations (breathing, subtle bounce)
            const tomBreath = Math.sin(time * 2 + tomOffset) * 0.02;
            const jerryBreath = Math.sin(time * 2.3 + jerryOffset) * 0.02;
            
            tomGroup.position.y = tomBreath;
            jerryGroup.position.y = jerryBreath;
            
            // Subtle hand movement (if bones exist, otherwise whole group subtle rotation)
            tomGroup.rotation.z = Math.sin(time * 1.5 + tomOffset) * 0.02;
            jerryGroup.rotation.z = Math.sin(time * 1.7 + jerryOffset) * 0.02;

            // Rain activation at climax
            if (phase > 1.5) {
                rainSystem.visible = true;
                const positions = rainSystem.geometry.attributes.position.array;
                
                for (let i = 0; i < rainCount; i++) {
                    positions[i * 3] += rainVelocities[i].x;
                    positions[i * 3 + 1] += rainVelocities[i].y;
                    positions[i * 3 + 2] += rainVelocities[i].z;
                    
                    // Reset if below ground
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = 10;
                        positions[i * 3] = (Math.random() - 0.5) * 20;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                    }
                }
                rainSystem.geometry.attributes.position.needsUpdate = true;
                
                // Glow increases
                bloomPass.strength = 0.3 + (phase - 1.5) * 0.4;
            } else {
                rainSystem.visible = false;
                bloomPass.strength = 0.3;
            }

            // Fog density changes with emotion
            scene.fog.density = 0.02 - (warmth * 0.015);

            composer.render();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
