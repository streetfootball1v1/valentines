<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Our Story — A Cinematic Experience</title>
    <style>
        :root {
            --primary: #ff2a6d;
            --secondary: #05d9e8;
            --dark: #01012b;
            --light: #d1f7ff;
            --gold: #ffd700;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Cormorant Garamond', 'Playfair Display', serif;
            background: var(--dark);
            color: var(--light);
            overflow: hidden;
            cursor: none;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }
        
        /* Cinematic UI */
        .cinematic-frame {
            position: fixed;
            pointer-events: none;
            z-index: 100;
        }
        
        .vignette {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.8) 100%);
            opacity: 0.6;
        }
        
        .grain {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            opacity: 0.03;
            animation: grain 0.5s steps(10) infinite;
        }
        
        @keyframes grain {
            0%, 100% { transform: translate(0, 0); }
            10% { transform: translate(-2%, -2%); }
            20% { transform: translate(2%, 2%); }
            30% { transform: translate(-1%, 1%); }
            40% { transform: translate(1%, -1%); }
            50% { transform: translate(-2%, 2%); }
            60% { transform: translate(2%, -2%); }
            70% { transform: translate(-1%, -1%); }
            80% { transform: translate(1%, 1%); }
            90% { transform: translate(-2%, -1%); }
        }
        
        .letterbox {
            position: fixed;
            left: 0;
            width: 100%;
            height: 12vh;
            background: #000;
            z-index: 90;
            transition: transform 1.2s cubic-bezier(0.77, 0, 0.175, 1);
        }
        
        .letterbox.top { top: 0; transform: translateY(-100%); }
        .letterbox.bottom { bottom: 0; transform: translateY(100%); }
        
        .letterbox.active {
            transform: translateY(0);
        }
        
        /* Text System */
        .subtitle-container {
            position: fixed;
            bottom: 15vh;
            left: 50%;
            transform: translateX(-50%);
            z-index: 80;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }
        
        .subtitle-container.visible {
            opacity: 1;
        }
        
        .subtitle {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            font-weight: 300;
            letter-spacing: 0.2em;
            text-shadow: 0 4px 20px rgba(0,0,0,0.8);
            margin-bottom: 0.5rem;
        }
        
        .subtitle-russian {
            font-size: clamp(2rem, 4vw, 3.5rem);
            color: var(--primary);
            text-shadow: 0 0 30px var(--primary);
        }
        
        /* Interactive cursor */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: transform 0.1s, opacity 0.3s;
            mix-blend-mode: difference;
        }
        
        .cursor.hover {
            transform: scale(2);
            background: var(--primary);
        }
        
        /* Progress */
        .timeline {
            position: fixed;
            bottom: 5vh;
            left: 10%;
            width: 80%;
            height: 2px;
            background: rgba(255,255,255,0.1);
            z-index: 80;
            opacity: 0;
            transition: opacity 1s;
        }
        
        .timeline.visible {
            opacity: 1;
        }
        
        .timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            width: 0%;
            box-shadow: 0 0 10px var(--primary);
            transition: width 0.1s linear;
        }
        
        /* Start overlay */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 1.5s, visibility 1.5s;
        }
        
        #start-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        
        .start-heart {
            width: 80px;
            height: 80px;
            background: var(--primary);
            position: relative;
            transform: rotate(-45deg);
            animation: heartbeat 2s ease infinite;
            cursor: pointer;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        
        .start-heart:hover {
            transform: rotate(-45deg) scale(1.2);
            box-shadow: 0 0 60px var(--primary);
        }
        
        .start-heart::before,
        .start-heart::after {
            content: '';
            width: 80px;
            height: 80px;
            position: absolute;
            background: var(--primary);
            border-radius: 50%;
        }
        
        .start-heart::before { top: -40px; left: 0; }
        .start-heart::after { left: 40px; top: 0; }
        
        @keyframes heartbeat {
            0%, 100% { transform: rotate(-45deg) scale(1); }
            25% { transform: rotate(-45deg) scale(1.1); }
            50% { transform: rotate(-45deg) scale(1); }
            75% { transform: rotate(-45deg) scale(1.05); }
        }
        
        .start-text {
            margin-top: 60px;
            font-size: 1.2rem;
            letter-spacing: 0.5em;
            color: var(--light);
            opacity: 0.7;
        }
        
        /* Final title */
        .final-title {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 70;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s;
        }
        
        .final-title.visible {
            opacity: 1;
        }
        
        .final-title h1 {
            font-size: clamp(4rem, 10vw, 8rem);
            font-weight: 300;
            letter-spacing: 0.3em;
            color: var(--gold);
            text-shadow: 0 0 60px var(--gold);
            margin-bottom: 1rem;
        }
        
        .final-title p {
            font-size: clamp(1.5rem, 3vw, 2rem);
            letter-spacing: 0.2em;
            color: var(--light);
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <div class="start-heart" onclick="startExperience()"></div>
        <div class="start-text">CLICK TO BEGIN OUR STORY</div>
    </div>

    <div class="cinematic-frame vignette"></div>
    <div class="cinematic-frame grain"></div>
    
    <div class="letterbox top" id="letterboxTop"></div>
    <div class="letterbox bottom" id="letterboxBottom"></div>

    <div id="canvas-container"></div>

    <div class="subtitle-container" id="subtitles">
        <div class="subtitle" id="subtitleEng"></div>
        <div class="subtitle-russian" id="subtitleRus"></div>
    </div>

    <div class="timeline" id="timeline">
        <div class="timeline-progress" id="timelineProgress"></div>
    </div>

    <div class="final-title" id="finalTitle">
        <h1>выбираю тебя</h1>
        <p>Always. Forever.</p>
    </div>

    <div class="cursor" id="cursor"></div>

    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=Playfair+Display:wght@300;400&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';

        // SCENARIO - Cinematic beats
        const SCENARIO = [
            { time: 0,    eng: "", rus: "", camera: "wide", action: "idle" },
            { time: 3,    eng: "Almost 4 years...", rus: "Почти 4 года…", camera: "dolly_in", action: "notice" },
            { time: 8,    eng: "Through every moment", rus: "Через каждое мгновение", camera: "orbit", action: "turn" },
            { time: 13,   eng: "We found our way", rus: "Мы нашли свой путь", camera: "close", action: "walk" },
            { time: 18,   eng: "And I still...", rus: "И я до сих пор…", camera: "intimate", action: "reach" },
            { time: 23,   eng: "", rus: "выбираю тебя", camera: "climax", action: "embrace" }
        ];

        let currentBeat = 0;
        let sceneTime = 0;
        let isPlaying = false;

        // THREE SETUP
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x01012b, 0.08);
        scene.background = new THREE.Color(0x01012b);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // POST PROCESSING
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.5, 0.6, 0.3
        );
        composer.addPass(bloomPass);

        // CINEMATIC LIGHTING - Three-point with drama
        const keyLight = new THREE.SpotLight(0xffd4e5, 150);
        keyLight.position.set(-3, 5, 4);
        keyLight.angle = Math.PI / 8;
        keyLight.penumbra = 0.7;
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.set(4096, 4096);
        keyLight.shadow.bias = -0.0001;
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0x05d9e8, 20);
        fillLight.position.set(4, 2, 2);
        scene.add(fillLight);

        const backLight = new THREE.SpotLight(0xff2a6d, 100);
        backLight.position.set(0, 4, -5);
        backLight.lookAt(0, 0, 0);
        scene.add(backLight);

        const ambientLight = new THREE.AmbientLight(0x01012b, 0.3);
        scene.add(ambientLight);

        // CHARACTERS
        const tomGroup = new THREE.Group();
        const jerryGroup = new THREE.Group();
        let tomModel = null, jerryModel = null;
        let modelsReady = false;

        // CONNECTION LINE (visual metaphor)
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-5, 1, 0),
            new THREE.Vector3(0, 2, 0),
            new THREE.Vector3(5, 1, 0)
        ]);
        
        const connectionGeo = new THREE.TubeGeometry(curve, 64, 0.02, 8, false);
        const connectionMat = new THREE.MeshBasicMaterial({
            color: 0xff2a6d,
            transparent: true,
            opacity: 0
        });
        const connectionLine = new THREE.Mesh(connectionGeo, connectionMat);
        scene.add(connectionLine);

        // PARTICLES - Emotional atmosphere
        const particleCount = 50;
        const particles = new THREE.InstancedMesh(
            new THREE.SphereGeometry(0.03, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0x05d9e8 }),
            particleCount
        );
        
        const particleData = [];
        for (let i = 0; i < particleCount; i++) {
            particleData.push({
                baseX: (Math.random() - 0.5) * 8,
                baseY: 0.5 + Math.random() * 2,
                baseZ: (Math.random() - 0.5) * 4,
                speed: 0.2 + Math.random() * 0.3,
                phase: Math.random() * Math.PI * 2
            });
        }
        scene.add(particles);

        // GROUND - Reflective stage
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({
                color: 0x01012b,
                roughness: 0.1,
                metalness: 0.8
            })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // LOAD MODELS
        const loader = new GLTFLoader();

        function loadCharacter(url, group, isTom) {
            loader.load(url, (gltf) => {
                const model = gltf.scene;
                
                // Professional scaling
                const box = new THREE.Box3().setFromObject(model);
                const height = box.max.y - box.min.y;
                const scale = 1.7 / height;
                model.scale.setScalar(scale);
                
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x * scale;
                model.position.z = -center.z * scale;
                model.position.y = -box.min.y * scale;
                
                // Cinematic materials
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.roughness = 0.5;
                            child.material.metalness = 0.1;
                        }
                    }
                });
                
                group.add(model);
                
                if (isTom) tomModel = model;
                else jerryModel = model;
                
                if (tomModel && jerryModel) {
                    modelsReady = true;
                    // Initial positions
                    tomGroup.position.set(-5, 0, 0);
                    jerryGroup.position.set(5, 0, 0);
                    tomGroup.rotation.y = Math.PI / 2;
                    jerryGroup.rotation.y = -Math.PI / 2;
                }
            });
        }

        loadCharacter('https://streetfootball1v1.github.io/valentines/models/Tom.glb', tomGroup, true);
        loadCharacter('https://streetfootball1v1.github.io/valentines/models/DJerry.glb', jerryGroup, false);

        scene.add(tomGroup);
        scene.add(jerryGroup);

        // CINEMATIC CAMERA SYSTEM
        const cameraStates = {
            wide: { pos: new THREE.Vector3(0, 2, 12), lookAt: new THREE.Vector3(0, 1, 0), fov: 50 },
            dolly_in: { pos: new THREE.Vector3(0, 1.5, 8), lookAt: new THREE.Vector3(0, 1.2, 0), fov: 40 },
            orbit: { pos: new THREE.Vector3(6, 2, 6), lookAt: new THREE.Vector3(0, 1.2, 0), fov: 35 },
            close: { pos: new THREE.Vector3(0, 1.3, 4), lookAt: new THREE.Vector3(0, 1.4, 0), fov: 30 },
            intimate: { pos: new THREE.Vector3(2, 1.4, 3), lookAt: new THREE.Vector3(0, 1.5, 0), fov: 25 },
            climax: { pos: new THREE.Vector3(0, 1.5, 2.5), lookAt: new THREE.Vector3(0, 1.6, 0), fov: 20 }
        };

        let currentCameraState = 'wide';
        let cameraTransition = 0;

        function updateCamera(delta) {
            const target = cameraStates[currentCameraState];
            cameraTransition = Math.min(cameraTransition + delta * 0.5, 1);
            
            // Smooth interpolation
            camera.position.lerp(target.pos, 0.02);
            
            const currentLookAt = new THREE.Vector3(0, 1.2, 0);
            currentLookAt.lerp(target.lookAt, 0.02);
            camera.lookAt(currentLookAt);
            
            camera.fov = THREE.MathUtils.lerp(camera.fov, target.fov, 0.02);
            camera.updateProjectionMatrix();
        }

        // ANIMATION SYSTEM
        function animateCharacters(time, delta) {
            if (!tomModel || !jerryModel) return;

            const beat = SCENARIO[currentBeat] || SCENARIO[SCENARIO.length - 1];
            
            // Tom animation states
            switch(beat.action) {
                case 'idle':
                    tomGroup.position.y = Math.sin(time) * 0.02;
                    jerryGroup.position.y = Math.sin(time + 1) * 0.02;
                    break;
                    
                case 'notice':
                    // Turn to look at each other
                    const turnProgress = Math.min((sceneTime - beat.time) / 3, 1);
                    tomGroup.rotation.y = THREE.MathUtils.lerp(Math.PI / 2, Math.PI / 4, turnProgress);
                    jerryGroup.rotation.y = THREE.MathUtils.lerp(-Math.PI / 2, -Math.PI / 4, turnProgress);
                    break;
                    
                case 'walk':
                    // Walk toward each other
                    const walkProgress = Math.min((sceneTime - beat.time) / 5, 1);
                    tomGroup.position.x = THREE.MathUtils.lerp(-5, -1.5, walkProgress);
                    jerryGroup.position.x = THREE.MathUtils.lerp(5, 1.5, walkProgress);
                    
                    // Walking bob
                    const bob = Math.abs(Math.sin(time * 8)) * 0.1;
                    tomGroup.position.y = bob;
                    jerryGroup.position.y = bob;
                    break;
                    
                case 'reach':
                    // Slow approach, hands reaching
                    const reachProgress = Math.min((sceneTime - beat.time) / 3, 1);
                    tomGroup.position.x = THREE.MathUtils.lerp(-1.5, -0.8, reachProgress);
                    jerryGroup.position.x = THREE.MathUtils.lerp(1.5, 0.8, reachProgress);
                    
                    // Connection line appears
                    connectionMat.opacity = reachProgress * 0.5;
                    break;
                    
                case 'embrace':
                    // Final embrace
                    tomGroup.position.x = THREE.MathUtils.lerp(-0.8, -0.4, 0.1);
                    jerryGroup.position.x = THREE.MathUtils.lerp(0.8, 0.4, 0.1);
                    tomGroup.rotation.y = Math.PI / 6;
                    jerryGroup.rotation.y = -Math.PI / 6;
                    
                    // Intense bloom
                    bloomPass.strength = 1.5 + Math.sin(time * 3) * 0.3;
                    connectionMat.opacity = 0.8;
                    break;
            }
        }

        // UI UPDATES
        function updateSubtitles() {
            const beat = SCENARIO.find((b, i) => {
                const next = SCENARIO[i + 1];
                return sceneTime >= b.time && (!next || sceneTime < next.time);
            });
            
            if (beat && (beat.eng || beat.rus)) {
                document.getElementById('subtitleEng').textContent = beat.eng;
                document.getElementById('subtitleRus').textContent = beat.rus;
                document.getElementById('subtitles').classList.add('visible');
            } else {
                document.getElementById('subtitles').classList.remove('visible');
            }
            
            // Update camera state
            if (beat && beat.camera !== currentCameraState) {
                currentCameraState = beat.camera;
                cameraTransition = 0;
            }
            
            // Check beat progression
            const nextBeat = SCENARIO[currentBeat + 1];
            if (nextBeat && sceneTime >= nextBeat.time) {
                currentBeat++;
            }
        }

        // MAIN LOOP
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (isPlaying && modelsReady) {
                sceneTime += delta;
                updateCamera(delta);
                animateCharacters(time, delta);
                updateSubtitles();
                
                // Timeline
                const totalTime = SCENARIO[SCENARIO.length - 1].time + 5;
                const progress = Math.min(sceneTime / totalTime, 1);
                document.getElementById('timelineProgress').style.width = `${progress * 100}%`;
                
                // Final title
                if (sceneTime > 22) {
                    document.getElementById('finalTitle').classList.add('visible');
                    document.getElementById('subtitles').classList.remove('visible');
                }
                
                // End
                if (sceneTime > 28) {
                    isPlaying = false;
                }
            }
            
            // Particles
            const dummy = new THREE.Object3D();
            for (let i = 0; i < particleCount; i++) {
                const data = particleData[i];
                const t = time * data.speed + data.phase;
                
                dummy.position.set(
                    data.baseX + Math.sin(t) * 0.5,
                    data.baseY + Math.sin(t * 0.5) * 0.3,
                    data.baseZ + Math.cos(t) * 0.5
                );
                
                dummy.scale.setScalar(1 + Math.sin(t * 2) * 0.5);
                dummy.updateMatrix();
                particles.setMatrixAt(i, dummy.matrix);
            }
            particles.instanceMatrix.needsUpdate = true;
            
            // Light animation
            keyLight.intensity = 100 + Math.sin(time * 0.5) * 20;
            backLight.intensity = 80 + Math.sin(time * 0.7 + 1) * 30;
            
            composer.render();
        }

        // INTERACTION
        window.startExperience = function() {
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('letterboxTop').classList.add('active');
            document.getElementById('letterboxBottom').classList.add('active');
            document.getElementById('timeline').classList.add('visible');
            
            setTimeout(() => {
                isPlaying = true;
                sceneTime = 0;
                currentBeat = 0;
            }, 1500);
        };

        // Cursor
        document.addEventListener('mousemove', (e) => {
            const cursor = document.getElementById('cursor');
            cursor.style.left = e.clientX - 10 + 'px';
            cursor.style.top = e.clientY - 10 + 'px';
        });

        document.querySelector('.start-heart').addEventListener('mouseenter', () => {
            document.getElementById('cursor').classList.add('hover');
        });

        document.querySelector('.start-heart').addEventListener('mouseleave', () => {
            document.getElementById('cursor').classList.remove('hover');
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
