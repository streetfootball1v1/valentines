<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alisher & Snezhana</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .story-text {
            color: white;
            font-size: 2rem;
            text-align: center;
            padding: 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            opacity: 0;
            transform: translateY(20px);
            max-width: 80%;
            pointer-events: none;
        }

        .heart-btn {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 40px rgba(255, 107, 107, 0.6);
            transition: transform 0.3s;
            animation: pulse 2s infinite;
            font-size: 50px;
        }

        .heart-btn:hover {
            transform: scale(1.1);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 40px rgba(255, 107, 107, 0.6); }
            50% { transform: scale(1.05); box-shadow: 0 0 60px rgba(255, 107, 107, 0.8); }
        }

        .final-btn {
            background: linear-gradient(45deg, #ff00cc, #333399);
            color: white;
            padding: 20px 50px;
            font-size: 1.5rem;
            border-radius: 50px;
            border: none;
            cursor: pointer;
            pointer-events: auto;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s;
            box-shadow: 0 0 30px rgba(255, 0, 204, 0.5);
            display: none;
        }

        .final-btn.show {
            display: block;
            opacity: 1;
            transform: scale(1);
        }

        .final-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 0, 204, 0.8);
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            z-index: 100;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ 3D...</div>
    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <div id="text-display" class="story-text">Once we were just two people...</div>
        <div id="heart-btn" class="heart-btn">‚ù§</div>
        <button id="final-btn" class="final-btn">Take the final step</button>
    </div>

    <script>
        // --- STATE ---
        const state = {
            scene: 1,
            distance: 12,
            lightIntensity: 0.5,
            isHoldingHands: false
        };

        // --- THREE.JS SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        document.getElementById('loading').classList.add('hidden');

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffd1dc, 0.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const loveLight = new THREE.PointLight(0xff69b4, 0, 30);
        loveLight.position.set(0, 2, 0);
        scene.add(loveLight);

        // --- ENVIRONMENT ---
        // Ground
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a40,
            roughness: 0.8 
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Stars
        const starsGeo = new THREE.BufferGeometry();
        const starCount = 200;
        const starPos = new Float32Array(starCount * 3);
        for(let i = 0; i < starCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 50;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const stars = new THREE.Points(starsGeo, starsMat);
        scene.add(stars);

        // --- CHARACTERS (Fixed for r128) ---
        function createChibi(color, isMale) {
            const group = new THREE.Group();

            // Materials
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const clothesMat = new THREE.MeshStandardMaterial({ color: color });
            const hairMat = new THREE.MeshStandardMaterial({ color: isMale ? 0x4a3728 : 0xf4d03f });

            // Body (Cylinder + Sphere top instead of Capsule)
            const bodyGroup = new THREE.Group();
            
            const bodyCyl = new THREE.Mesh(
                new THREE.CylinderGeometry(0.7, 0.7, 1.5, 16),
                clothesMat
            );
            bodyCyl.position.y = 0;
            bodyCyl.castShadow = true;
            bodyGroup.add(bodyCyl);
            
            // Rounded top for body
            const bodyTop = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                clothesMat
            );
            bodyTop.position.y = 0.75;
            bodyGroup.add(bodyTop);
            
            // Rounded bottom for body
            const bodyBot = new THREE.Mesh(
                new THREE.SphereGeometry(0.7, 16, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2),
                clothesMat
            );
            bodyBot.position.y = -0.75;
            bodyGroup.add(bodyBot);
            
            group.add(bodyGroup);

            // Head (Big for chibi style)
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(1.2, 32, 32),
                skinMat
            );
            head.position.y = 1.8;
            head.castShadow = true;
            group.add(head);

            // Hair
            const hair = new THREE.Mesh(
                new THREE.SphereGeometry(1.25, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2),
                hairMat
            );
            hair.position.y = 1.8;
            group.add(hair);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.4, 1.9, 1);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.4, 1.9, 1);
            group.add(rightEye);

            // Blush
            const blushGeo = new THREE.CircleGeometry(0.15, 16);
            const blushMat = new THREE.MeshBasicMaterial({ color: 0xff9999, transparent: true, opacity: 0.6 });
            
            const leftBlush = new THREE.Mesh(blushGeo, blushMat);
            leftBlush.position.set(-0.6, 1.7, 0.9);
            leftBlush.rotation.y = -0.3;
            group.add(leftBlush);

            return group;
        }

        const alisher = createChibi(0x6495ED, true);  // Blue
        const snezhana = createChibi(0xFFB6C1, false); // Pink
        
        scene.add(alisher);
        scene.add(snezhana);

        // --- ANIMATION LOOP ---
        let time = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // Move characters
            const halfDist = state.distance / 2;
            alisher.position.x += (-halfDist - alisher.position.x) * 0.05;
            snezhana.position.x += (halfDist - snezhana.position.x) * 0.05;

            // Face each other
            alisher.lookAt(snezhana.position.x, 0, 0);
            snezhana.lookAt(alisher.position.x, 0, 0);

            // Idle animation
            if (!state.isHoldingHands) {
                const bounce = Math.sin(time * 3) * 0.1;
                alisher.position.y = bounce;
                snezhana.position.y = bounce;
            } else {
                // Happy jump
                const jump = Math.abs(Math.sin(time * 10)) * 0.3;
                alisher.position.y = jump;
                snezhana.position.y = jump;
                alisher.rotation.y = 0;
                snezhana.rotation.y = 0;
            }

            // Rotate stars
            stars.rotation.y = time * 0.02;

            // Update light
            loveLight.intensity += (state.lightIntensity - loveLight.intensity) * 0.05;

            // Color shift
            const hue = 220 + (state.scene * 20);
            scene.background.setHSL(hue / 360, 0.5, 0.1);
            scene.fog.color.setHSL(hue / 360, 0.5, 0.1);

            renderer.render(scene, camera);
        }

        animate();

        // --- UI & STORY LOGIC ---
        const textDisplay = document.getElementById('text-display');
        const heartBtn = document.getElementById('heart-btn');
        const finalBtn = document.getElementById('final-btn');

        function showText(text, delay = 0) {
            setTimeout(() => {
                gsap.to(textDisplay, {
                    opacity: 0,
                    y: -20,
                    duration: 0.5,
                    onComplete: () => {
                        textDisplay.textContent = text;
                        gsap.to(textDisplay, { opacity: 1, y: 0, duration: 0.8 });
                    }
                });
            }, delay);
        }

        // Scene 1: Start
        gsap.to(textDisplay, { opacity: 1, y: 0, duration: 1, delay: 0.5 });

        // Scene 2: Heart click
        heartBtn.addEventListener('click', () => {
            if (state.scene !== 1) return;
            state.scene = 2;

            // Hide heart
            gsap.to(heartBtn, { scale: 0, opacity: 0, duration: 0.5 });
            
            // Move closer
            state.distance = 6;
            state.lightIntensity = 2;
            
            showText("And everything started with a single step‚Ä¶");

            // Scene 3
            setTimeout(() => {
                state.scene = 3;
                state.distance = 3;
                state.lightIntensity = 4;
                showText("Laughter, support, and 'we' instead of 'me'‚Ä¶");
                
                // Add floating hearts
                addFloatingHearts();
            }, 4000);

            // Scene 4
            setTimeout(() => {
                state.scene = 4;
                state.distance = 1.5;
                showText("Almost 4 years‚Ä¶");
            }, 8000);

            setTimeout(() => {
                showText("And I choose you every day.");
            }, 11000);

            // Scene 5
            setTimeout(() => {
                state.scene = 5;
                gsap.to(textDisplay, { opacity: 0, duration: 0.5 });
                finalBtn.classList.add('show');
            }, 14000);
        });

        // Final button
        finalBtn.addEventListener('click', () => {
            state.isHoldingHands = true;
            state.distance = 0.5;
            state.lightIntensity = 8;
            
            gsap.to(finalBtn, { scale: 0, opacity: 0, duration: 0.5 });
            
            // Confetti effect
            createConfetti();
            
            setTimeout(() => {
                textDisplay.innerHTML = "Will you be my Valentine? üíù";
                textDisplay.style.fontSize = "3rem";
                gsap.to(textDisplay, { opacity: 1, scale: 1.1, duration: 1 });
            }, 1000);
        });

        // Floating hearts in 3D
        function addFloatingHearts() {
            const heartShape = new THREE.Shape();
            heartShape.moveTo(0.25, 0.25);
            heartShape.bezierCurveTo(0.25, 0.25, 0.20, 0, 0, 0);
            heartShape.bezierCurveTo(-0.30, 0, -0.30, 0.35, -0.30, 0.35);
            heartShape.bezierCurveTo(-0.30, 0.55, -0.10, 0.77, 0.25, 0.95);
            heartShape.bezierCurveTo(0.60, 0.77, 0.80, 0.55, 0.80, 0.35);
            heartShape.bezierCurveTo(0.80, 0.35, 0.80, 0, 0.50, 0);
            heartShape.bezierCurveTo(0.35, 0, 0.25, 0.25, 0.25, 0.25);

            const geometry = new THREE.ShapeGeometry(heartShape);
            const material = new THREE.MeshBasicMaterial({ color: 0xff69b4, side: THREE.DoubleSide });

            for (let i = 0; i < 15; i++) {
                const heart = new THREE.Mesh(geometry, material);
                heart.scale.set(0.3, 0.3, 0.3);
                heart.position.set(
                    (Math.random() - 0.5) * 15,
                    Math.random() * 8,
                    (Math.random() - 0.5) * 10
                );
                heart.rotation.z = Math.PI;
                scene.add(heart);

                // Animate
                gsap.to(heart.position, {
                    y: heart.position.y + 5,
                    duration: 3 + Math.random() * 2,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
        }

        // Simple confetti
        function createConfetti() {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const geometry = new THREE.PlaneGeometry(0.2, 0.2);
            
            for (let i = 0; i < 100; i++) {
                const material = new THREE.MeshBasicMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)],
                    side: THREE.DoubleSide
                });
                const confetti = new THREE.Mesh(geometry, material);
                
                confetti.position.set(0, 5, 0);
                confetti.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                
                scene.add(confetti);

                // Explode outward
                const angle = Math.random() * Math.PI * 2;
                const velocity = 5 + Math.random() * 10;
                
                gsap.to(confetti.position, {
                    x: Math.cos(angle) * velocity,
                    y: Math.random() * 10,
                    z: Math.sin(angle) * velocity,
                    duration: 2,
                    ease: "power2.out"
                });
                
                gsap.to(confetti.rotation, {
                    x: Math.random() * 10,
                    y: Math.random() * 10,
                    duration: 2
                });
            }
        }

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Mouse parallax
        document.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth - 0.5) * 2;
            const y = (e.clientY / window.innerHeight - 0.5) * 2;
            
            gsap.to(camera.position, {
                x: x * 2,
                y: 3 + y * 0.5,
                duration: 1
            });
        });

    </script>
</body>
</html>
