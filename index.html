<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bridge of Love - A Cinematic 3D Experience</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    
    <!-- Three.js & Post Processing -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Lato:wght@300;400&display=swap');

        body {
            margin: 0;
            overflow-x: hidden;
            background-color: #1a1a2e;
            font-family: 'Lato', sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        /* Scroll Track */
        #scroll-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 600vh; /* Long scroll distance for narrative */
            z-index: 0;
            pointer-events: none;
        }

        /* UI Layer */
        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .narrative-text {
            font-family: 'Playfair Display', serif;
            color: white;
            text-align: center;
            opacity: 0;
            text-shadow: 0 4px 20px rgba(0,0,0,0.5);
            position: absolute;
            max-width: 800px;
            padding: 0 20px;
            transform: translateY(20px);
        }

        .narrative-text h1 {
            font-size: 3rem;
            margin-bottom: 1rem;
            font-style: italic;
        }

        .narrative-text p {
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 1px;
        }

        /* The Final Button */
        #final-step-btn {
            pointer-events: auto;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            border: none;
            padding: 20px 50px;
            font-size: 1.5rem;
            font-family: 'Playfair Display', serif;
            color: #4a3b00;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
            opacity: 0;
            transform: scale(0.8);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: none; /* Hidden initially */
        }

        #final-step-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.9);
        }

        #final-question {
            font-family: 'Playfair Display', serif;
            font-size: 4rem;
            color: #fff;
            text-shadow: 0 0 30px #ff69b4;
            opacity: 0;
            position: absolute;
            text-align: center;
            display: none;
        }

        /* Loader */
        #loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Playfair Display', serif;
            font-size: 2rem;
            transition: opacity 1s ease;
        }
    </style>
</head>
<body>

    <!-- Loader -->
    <div id="loader">Generating World...</div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Scroll Track (Invisible but functional) -->
    <div id="scroll-track"></div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        
        <!-- Scene 1 Text -->
        <div class="narrative-text" id="text-1">
            <h1>When there was distance between us...</h1>
        </div>

        <!-- Scene 2 Text -->
        <div class="narrative-text" id="text-2">
            <p>Step by step...</p>
        </div>

        <!-- Scene 4 Text -->
        <div class="narrative-text" id="text-3">
            <h1>Almost 4 years...</h1>
        </div>
        
        <div class="narrative-text" id="text-4">
            <h1>And every day...</h1>
        </div>

        <div class="narrative-text" id="text-5">
            <h1>I choose you.</h1>
        </div>

        <!-- Final Button -->
        <button id="final-step-btn">Take the final step</button>

        <!-- Final Question -->
        <div id="final-question">
            Will you be my Valentine? üíù
        </div>
    </div>

    <!-- Application Script -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            colors: {
                bg: 0x1a1a2e,
                fogStart: 0x2a2a40,
                fogEnd: 0xffd1dc, // Pinkish white
                island1: 0x9fa8da, // Lavender
                island2: 0xf48fb1, // Pink
                bridge: 0xffd700,  // Gold
                alisher: 0x64b5f6, // Blue tones
                snezhana: 0xf06292 // Pink tones
            },
            bridgeLength: 40,
            walkDistance: 18 // How far they walk towards center
        };

        // --- Global Variables ---
        let scene, camera, renderer, composer, controls;
        let alisher, snezhana, bridge;
        let particles, particleGeo;
        let cursorLight;
        let mouse = new THREE.Vector2();
        let targetMouse = new THREE.Vector2();
        let scrollProgress = 0;
        let isClimax = false;
        let timeScale = 1.0;
        let clock = new THREE.Clock();
        
        // Animation Mixers/States
        const state = {
            bridgeBuilt: 0, // 0 to 1
            walkProgress: 0, // 0 to 1
            cameraZoom: 60
        };

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.fogStart, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 60);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.SoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post Processing (Bloom)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 0.4; // Initial subtle bloom
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Lighting
            setupLighting();

            // World Building
            createEnvironment();
            createCharacters();
            createParticles();
            createBridge();

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            document.getElementById('final-step-btn').addEventListener('click', triggerClimax);

            // GSAP ScrollTrigger Setup
            setupScrollAnimations();

            // Start Loop
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);
            animate();
        }

        function setupLighting() {
            // Ambient
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
            scene.add(ambientLight);

            // Directional (Moon/Sun)
            const dirLight = new THREE.DirectionalLight(0xffd1dc, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // Cursor Interactive Light
            cursorLight = new THREE.PointLight(0xffaa00, 0, 20);
            scene.add(cursorLight);
        }

        // --- Procedural Generation Helpers ---
        
        function createIsland(xPos, color) {
            const group = new THREE.Group();
            
            // Main rock
            const geo = new THREE.CylinderGeometry(6, 4, 8, 7);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: 0.8,
                flatShading: true
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = -4;
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            group.add(mesh);

            // Grass top
            const grassGeo = new THREE.CylinderGeometry(6.2, 6, 1, 7);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x81c784 });
            const grass = new THREE.Mesh(grassGeo, grassMat);
            grass.position.y = 0.5;
            grass.receiveShadow = true;
            group.add(grass);

            // Floating animation offset
            group.userData = { 
                initialY: 0, 
                floatSpeed: 0.002 + Math.random() * 0.001,
                floatOffset: Math.random() * Math.PI 
            };
            
            group.position.set(xPos, 0, 0);
            scene.add(group);
            return group;
        }

        function createChibiCharacter(name, colors) {
            const group = new THREE.Group();
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffe0bd, roughness: 0.4 });
            const clothesMat = new THREE.MeshStandardMaterial({ color: colors.clothes, roughness: 0.6 });
            const hairMat = new THREE.MeshStandardMaterial({ color: colors.hair, roughness: 0.7 });

            // Body (Chubby capsule-like)
            const bodyGeo = new THREE.CapsuleGeometry(0.8, 1.2, 4, 8);
            const body = new THREE.Mesh(bodyGeo, clothesMat);
            body.position.y = 1.6;
            body.castShadow = true;
            group.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(1.1, 16, 16);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 3.2;
            head.castShadow = true;
            group.add(head);

            // Hair (Simple hemisphere)
            const hairGeo = new THREE.SphereGeometry(1.15, 16, 16, 0, Math.PI * 2, 0, Math.PI/2.5);
            const hair = new THREE.Mesh(hairGeo, hairMat);
            hair.position.y = 3.3;
            hair.castShadow = true;
            group.add(hair);

            // Eyes (Big and expressive)
            const eyeGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.1 });
            
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.35, 3.3, 0.9);
            group.add(eyeL);

            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.35, 3.3, 0.9);
            group.add(eyeR);

            // Blush
            const blushGeo = new THREE.CircleGeometry(0.15, 16);
            const blushMat = new THREE.MeshBasicMaterial({ color: 0xffa0a0, transparent: true, opacity: 0.5 });
            const blushL = new THREE.Mesh(blushGeo, blushMat);
            blushL.position.set(-0.6, 3.0, 0.95);
            blushL.rotation.y = -0.5;
            group.add(blushL);
            
            const blushR = new THREE.Mesh(blushGeo, blushMat);
            blushR.position.set(0.6, 3.0, 0.95);
            blushR.rotation.y = 0.5;
            group.add(blushR);

            // Glow Mesh (for interaction)
            const glowGeo = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            glow.position.y = 2.5;
            glow.name = "glow";
            group.add(glow);

            scene.add(group);
            return group;
        }

        // --- Scene Construction ---

        function createEnvironment() {
            // Left Island (Alisher)
            createIsland(-CONFIG.bridgeLength / 2, CONFIG.colors.island1);
            // Right Island (Snezhana)
            createIsland(CONFIG.bridgeLength / 2, CONFIG.colors.island2);
        }

        function createCharacters() {
            // Alisher (Left)
            alisher = createChibiCharacter("Alisher", { 
                clothes: 0x5c6bc0, // Indigo
                hair: 0x3e2723    // Dark Brown
            });
            alisher.position.set(-CONFIG.bridgeLength / 2, 1, 0);
            alisher.rotation.y = Math.PI / 2; // Face right

            // Snezhana (Right)
            snezhana = createChibiCharacter("Snezhana", { 
                clothes: 0xf48fb1, // Pink
                hair: 0xffecb3     // Blonde
            });
            snezhana.position.set(CONFIG.bridgeLength / 2, 1, 0);
            snezhana.rotation.y = -Math.PI / 2; // Face left
        }

        function createBridge() {
            // The bridge is made of segments that scale up
            const segmentCount = 20;
            const segmentWidth = CONFIG.bridgeLength / segmentCount;
            
            bridge = new THREE.Group();

            for(let i = 0; i < segmentCount; i++) {
                const geo = new THREE.BoxGeometry(segmentWidth - 0.2, 0.5, 2);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: CONFIG.colors.bridge,
                    emissive: CONFIG.colors.bridge,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0
                });
                const segment = new THREE.Mesh(geo, mat);
                
                // Position from left to right
                const xPos = (-CONFIG.bridgeLength / 2) + (i * segmentWidth) + (segmentWidth/2);
                segment.position.set(xPos, -0.5, 0);
                
                // Store initial scale for animation
                segment.userData = { 
                    finalY: -0.5, 
                    index: i,
                    total: segmentCount
                };
                
                // Start invisible and below
                segment.scale.set(1, 0, 1);
                segment.position.y = -5;

                bridge.add(segment);
            }
            scene.add(bridge);
        }

        function createParticles() {
            const count = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const speeds = new Float32Array(count);

            for(let i = 0; i < count; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100; // x
                positions[i * 3 + 1] = (Math.random() - 0.5) * 50 + 10; // y
                positions[i * 3 + 2] = (Math.random() - 0.5) * 50; // z
                speeds[i] = Math.random() * 0.02 + 0.005;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));

            const material = new THREE.PointsMaterial({
                color: 0xffd700,
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- Logic & Animation ---

        function setupScrollAnimations() {
            gsap.registerPlugin(ScrollTrigger);

            // Master Timeline tied to scroll
            const tl = gsap.timeline({
                scrollTrigger: {
                    trigger: "#scroll-track",
                    start: "top top",
                    end: "bottom bottom",
                    scrub: 1,
                    onUpdate: (self) => {
                        scrollProgress = self.progress;
                    }
                }
            });

            // SCENE 1: Distance (0% - 20%)
            // Just camera movement and text fade in/out handled by CSS/JS in animate loop
            tl.to("#text-1", { opacity: 1, duration: 0.1 }, 0);
            tl.to("#text-1", { opacity: 0, duration: 0.1 }, 0.2);

            // SCENE 2: Bridge Forms (20% - 40%)
            tl.to("#text-2", { opacity: 1, duration: 0.1 }, 0.25);
            tl.to(state, { bridgeBuilt: 1, duration: 0.2, ease: "power2.inOut" }, 0.2);
            tl.to("#text-2", { opacity: 0, duration: 0.1 }, 0.4);

            // SCENE 3: Walking (40% - 70%)
            tl.to(state, { walkProgress: 1, duration: 0.3 }, 0.4);
            // Fog and color change handled in animate loop based on walkProgress

            // SCENE 4: Near (70% - 85%) - Pause effect
            tl.to("#text-3", { opacity: 1, duration: 0.05 }, 0.7);
            tl.to("#text-3", { opacity: 0, duration: 0.05 }, 0.75);
            
            tl.to("#text-4", { opacity: 1, duration: 0.05 }, 0.77);
            tl.to("#text-4", { opacity: 0, duration: 0.05 }, 0.82);

            tl.to("#text-5", { opacity: 1, duration: 0.05 }, 0.84);
            tl.to("#text-5", { opacity: 0, duration: 0.05 }, 0.9);

            // SCENE 5: Reveal Button (85%+)
            tl.call(() => {
                if(!isClimax) {
                    const btn = document.getElementById('final-step-btn');
                    btn.style.display = 'block';
                    gsap.to(btn, { opacity: 1, scale: 1, duration: 1, ease: "back.out(1.7)" });
                }
            }, null, 0.9);
        }

        function onMouseMove(event) {
            // Normalize mouse coordinates -1 to 1
            targetMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            targetMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function triggerClimax() {
            if(isClimax) return;
            isClimax = true;

            const btn = document.getElementById('final-step-btn');
            gsap.to(btn, { opacity: 0, scale: 0, duration: 0.5 });
            
            // 1. Slow Motion Effect
            gsap.to(window, { 
                timeScale: 0.2, 
                duration: 1,
                onUpdate: () => { timeScale = gsap.globalTimeline.timeScale(); }
            });

            // 2. Move Characters to Center
            gsap.to(alisher.position, { x: -1.5, duration: 3, ease: "power2.inOut" });
            gsap.to(snezhana.position, { x: 1.5, duration: 3, ease: "power2.inOut" });

            // Rotate to face forward/camera slightly
            gsap.to(alisher.rotation, { y: Math.PI / 4, duration: 3 });
            gsap.to(snezhana.rotation, { y: -Math.PI / 4, duration: 3 });

            // 3. Light Burst & Bloom
            gsap.to(cursorLight, { intensity: 5, distance: 50, duration: 2 });
            gsap.to(composer.passes[1], { strength: 3, radius: 1, duration: 2 }); // Bloom

            // 4. Particle Explosion
            explodeParticles();

            // 5. Camera Orbit
            gsap.to(camera.position, {
                x: 0,
                y: 5,
                z: 10,
                duration: 5,
                ease: "power2.out"
            });

            // 6. Final Text
            setTimeout(() => {
                const finalQ = document.getElementById('final-question');
                finalQ.style.display = 'block';
                gsap.to(finalQ, { opacity: 1, duration: 2 });
                
                // Reset time scale slightly for breathing effect
                gsap.to(window, { timeScale: 1, duration: 2, delay: 1 });
            }, 2000);
        }

        function explodeParticles() {
            const positions = particles.geometry.attributes.position.array;
            const count = positions.length / 3;
            
            // We create a temporary object to tween values that we apply to particles
            const explosionData = { value: 0 };
            
            gsap.to(explosionData, {
                value: 1,
                duration: 2,
                onUpdate: () => {
                    // Radial explosion logic
                    for(let i = 0; i < count; i++) {
                        // Simple noise based on index
                        const ix = i * 3;
                        const iy = i * 3 + 1;
                        const iz = i * 3 + 2;
                        
                        // Push particles outward from center
                        positions[ix] += (Math.random() - 0.5) * 0.5;
                        positions[iy] += Math.random() * 0.5; // Upward
                        positions[iz] += (Math.random() - 0.5) * 0.5;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            });
        }

        function updateBridge() {
            if(!bridge) return;
            
            bridge.children.forEach((segment, i) => {
                // Determine if this segment should be visible based on bridgeBuilt (0 to 1)
                // Map bridgeBuilt (0-1) to segment index (0-total)
                const threshold = state.bridgeBuilt * bridge.children.length;
                
                if(i < threshold) {
                    // Animate in
                    segment.material.opacity = 1;
                    segment.position.y = THREE.MathUtils.lerp(segment.position.y, segment.userData.finalY, 0.1);
                    segment.scale.y = THREE.MathUtils.lerp(segment.scale.y, 1, 0.1);
                } else {
                    // Animate out
                    segment.material.opacity = 0;
                    segment.position.y = THREE.MathUtils.lerp(segment.position.y, -5, 0.1);
                    segment.scale.y = THREE.MathUtils.lerp(segment.scale.y, 0, 0.1);
                }
            });
        }

        function updateCharacters() {
            if(!alisher || !snezhana) return;

            // Calculate target positions based on walkProgress
            // Start at +/- 20, end at +/- 2 (leaving gap for final step)
            const startX = CONFIG.bridgeLength / 2;
            const endX = 2.5; 
            const currentTravel = (startX - endX) * state.walkProgress;

            if(!isClimax) {
                // Normal walking animation
                alisher.position.x = -startX + currentTravel;
                snezhana.position.x = startX - currentTravel;

                // Bobbing walk animation
                const walkCycle = Date.now() * 0.005 * (state.walkProgress > 0 ? 2 : 0.5);
                alisher.position.y = 1 + Math.abs(Math.sin(walkCycle)) * 0.2;
                snezhana.position.y = 1 + Math.abs(Math.sin(walkCycle + Math.PI)) * 0.2;

                // Rotate towards each other as they get closer
                const lookAngle = (1 - state.walkProgress) * (Math.PI / 2);
                alisher.rotation.y = lookAngle;
                snezhana.rotation.y = -lookAngle;
            }
        }

        function updateEnvironment() {
            // Fog color shift based on walk progress
            // Start: Dark Blue/Grey -> End: Warm Gold/Pink
            const c1 = new THREE.Color(CONFIG.colors.fogStart);
            const c2 = new THREE.Color(CONFIG.colors.fogEnd);
            const finalColor = c1.lerp(c2, state.walkProgress);
            
            scene.fog.color.copy(finalColor);
            scene.background.lerp(finalColor, 0.05);

            // Particle color shift
            if(particles) {
                particles.material.color.lerp(new THREE.Color(0xff69b4), 0.01);
            }
        }

        function updateCursorLight() {
            // Smooth mouse follow
            mouse.lerp(targetMouse, 0.05);

            // Project mouse into 3D space roughly
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.z / dir.z * 0.8; // Project to roughly Z=0 plane
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));
            
            // Limit range so it doesn't go too far
            pos.x = THREE.MathUtils.clamp(pos.x, -30, 30);
            pos.y = THREE.MathUtils.clamp(pos.y, 0, 20);
            pos.z = THREE.MathUtils.clamp(pos.z, -10, 10);

            cursorLight.position.copy(pos);

            // Interactive Glow on Characters
            [alisher, snezhana].forEach(char => {
                if(!char) return;
                const dist = cursorLight.position.distanceTo(char.position);
                const glowMesh = char.getObjectByName("glow");
                
                if(dist < 8) {
                    // Intensity increases as they get closer to each other (state.walkProgress)
                    // and as mouse gets close
                    const proximityFactor = 1 - (dist / 8);
                    const loveFactor = state.walkProgress;
                    
                    glowMesh.material.opacity = proximityFactor * 0.5 * (1 + loveFactor);
                    
                    // If very close to climax, bloom the characters
                    if(state.walkProgress > 0.8) {
                        glowMesh.material.color.setHex(0xffd700);
                    }
                } else {
                    glowMesh.material.opacity = THREE.MathUtils.lerp(glowMesh.material.opacity, 0, 0.1);
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta() * timeScale;

            // Update Logic
            updateBridge();
            updateCharacters();
            updateEnvironment();
            updateCursorLight();

            // Particle ambient movement
            if(particles) {
                const positions = particles.geometry.attributes.position.array;
                for(let i = 0; i < positions.length / 3; i++) {
                    positions[i*3 + 1] += Math.sin(Date.now() * 0.001 + i) * 0.02; // Y wiggle
                    // Reset if too high/low
                    if(positions[i*3+1] > 30) positions[i*3+1] = -10;
                }
                particles.geometry.attributes.position.needsUpdate = true;
                particles.rotation.y += 0.001;
            }

            // Camera subtle movement based on mouse
            if(!isClimax) {
                camera.position.x += (mouse.x * 2 - camera.position.x) * 0.02;
                camera.position.y += (15 + mouse.y * 2 - camera.position.y) * 0.02;
                camera.lookAt(0, 2, 0);
            } else {
                // Slow orbit during climax
                const time = Date.now() * 0.0005;
                camera.position.x = Math.sin(time) * 8;
                camera.position.z = Math.cos(time) * 8 + 5;
                camera.lookAt(0, 2, 0);
            }

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start
        init();

    </script>
</body>
</html>
