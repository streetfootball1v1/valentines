<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Almost 4 Years — A Cinematic 3D Story</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Cormorant Garamond', 'Playfair Display', Georgia, serif;
            overflow-x: hidden;
            background: #1a0f1a;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }
        
        .scroll-container {
            position: relative;
            z-index: 10;
        }
        
        .scene-section {
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            pointer-events: none;
        }
        
        .text-overlay {
            text-align: center;
            color: #fff0f5;
            text-shadow: 0 4px 30px rgba(255, 182, 193, 0.5);
            opacity: 0;
            transform: translateY(30px);
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            padding: 2rem;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .text-overlay.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .text-overlay h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 300;
            letter-spacing: 0.2em;
            margin-bottom: 1rem;
            line-height: 1.3;
            background: linear-gradient(135deg, #fff 0%, #ffb6c1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .text-overlay h2 {
            font-size: clamp(1.8rem, 4vw, 3rem);
            font-weight: 300;
            letter-spacing: 0.15em;
            opacity: 0.95;
            color: #ffe4e1;
        }
        
        .text-overlay p {
            font-size: clamp(1.3rem, 2.5vw, 2rem);
            font-weight: 300;
            letter-spacing: 0.1em;
            margin-top: 1.5rem;
            font-style: italic;
            color: #ffc0cb;
        }
        
        .fade-line {
            height: 1px;
            width: 150px;
            background: linear-gradient(90deg, transparent, rgba(255, 182, 193, 0.6), transparent);
            margin: 2rem auto;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #2d1b2d 0%, #0f050f 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1.5s ease;
        }
        
        .loading-text {
            font-size: 1.5rem;
            color: #ffb6c1;
            letter-spacing: 0.5em;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loading-text">LOADING SCENE...</div>
    </div>

    <div id="canvas-container"></div>

    <div class="scroll-container">
        <section class="scene-section" data-scene="0">
            <div class="text-overlay">
                <h1>Почти 4 года…</h1>
                <div class="fade-line"></div>
                <p>Scroll to begin</p>
            </div>
        </section>

        <section class="scene-section" data-scene="1">
            <div class="text-overlay">
                <h2>Every moment</h2>
                <h2>led us here</h2>
            </div>
        </section>

        <section class="scene-section" data-scene="2">
            <div class="text-overlay">
                <h2>И я до сих пор…</h2>
                <div class="fade-line"></div>
                <p>Closer with every step</p>
            </div>
        </section>

        <section class="scene-section" data-scene="3">
            <div class="text-overlay">
                <h1>выбираю тебя.</h1>
                <div class="fade-line"></div>
                <p>Always. Forever.</p>
            </div>
        </section>
    </div>

    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=Playfair+Display:wght@300;400&display=swap" rel="stylesheet">

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Scene setup - cinematic dark atmosphere
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x1a0f1a, 0.08);
        scene.background = new THREE.Color(0x1a0f1a);

        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.2, 6);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyCorrectLights = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Post-processing
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.4,
            0.5,
            0.7
        );
        composer.addPass(bloomPass);

        // DRAMATIC CINEMATIC LIGHTING
        // 1. Key Light - warm, soft, from side (main illumination)
        const keyLight = new THREE.SpotLight(0xffd4a3, 100);
        keyLight.position.set(-3, 3, 4);
        keyLight.angle = Math.PI / 5;
        keyLight.penumbra = 0.6;
        keyLight.decay = 2;
        keyLight.distance = 30;
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 4096;
        keyLight.shadow.mapSize.height = 4096;
        keyLight.shadow.bias = -0.0001;
        keyLight.shadow.radius = 8;
        scene.add(keyLight);

        // 2. Rim Light - strong backlight for silhouette
        const rimLight = new THREE.SpotLight(0xff69b4, 80);
        rimLight.position.set(0, 4, -4);
        rimLight.angle = Math.PI / 4;
        rimLight.penumbra = 0.7;
        rimLight.decay = 2;
        rimLight.distance = 30;
        scene.add(rimLight);

        // 3. Fill Light - cool, subtle
        const fillLight = new THREE.DirectionalLight(0x6a5acd, 3);
        fillLight.position.set(4, 2, 2);
        scene.add(fillLight);

        // 4. Ground bounce light
        const bounceLight = new THREE.DirectionalLight(0xffb6c1, 2);
        bounceLight.position.set(0, -2, 2);
        scene.add(bounceLight);

        // 5. Ambient
        const hemiLight = new THREE.HemisphereLight(0xffd1dc, 0x1a0f1a, 0.3);
        scene.add(hemiLight);

        // Character groups
        const tomGroup = new THREE.Group();
        const jerryGroup = new THREE.Group();
        
        let tomModel = null;
        let jerryModel = null;

        // Load glTF models
        const loader = new GLTFLoader();
        
        function loadCharacter(url, targetGroup, isTom) {
            loader.load(url, (gltf) => {
                const model = gltf.scene;
                
                // AUTO-SCALE to consistent size
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Target height: 1.7 units (consistent scale)
                const targetHeight = 1.7;
                const scale = targetHeight / size.y;
                model.scale.setScalar(scale);
                
                // Center and place on ground
                const center = box.getCenter(new THREE.Vector3());
                model.position.x = -center.x * scale;
                model.position.z = -center.z * scale;
                model.position.y = -box.min.y * scale; // Place feet on ground
                
                // Enable shadows and improve materials
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Enhance material
                        if (child.material) {
                            child.material.roughness = Math.max(child.material.roughness, 0.4);
                            child.material.metalness = Math.min(child.material.metalness, 0.1);
                            
                            // Add subtle SSS effect
                            if (child.material.color) {
                                const color = child.material.color;
                                // Slightly warm up skin tones
                                if (color.r > 0.5 && color.g > 0.3 && color.b > 0.2) {
                                    color.r = Math.min(color.r * 1.1, 1);
                                    color.g = Math.min(color.g * 0.95, 1);
                                }
                            }
                        }
                    }
                });
                
                targetGroup.add(model);
                
                if (isTom) {
                    tomModel = model;
                    // Tom on left, facing right
                    targetGroup.position.set(-2.5, 0, 0);
                    targetGroup.rotation.y = Math.PI / 8;
                } else {
                    jerryModel = model;
                    // Jerry on right, facing left
                    targetGroup.position.set(2.5, 0, 0);
                    targetGroup.rotation.y = -Math.PI / 8;
                }
                
                console.log(`Loaded ${isTom ? 'Tom' : 'Jerry'}: height=${size.y.toFixed(2)}, scale=${scale.toFixed(2)}`);
                
            }, undefined, (error) => {
                console.error(`Failed to load ${isTom ? 'Tom' : 'Jerry'}:`, error);
            });
        }

        // Load models
        loadCharacter(
            'https://streetfootball1v1.github.io/valentines/models/Tom.glb',
            tomGroup,
            true
        );
        
        loadCharacter(
            'https://streetfootball1v1.github.io/valentines/models/DJerry.glb',
            jerryGroup,
            false
        );

        scene.add(tomGroup);
        scene.add(jerryGroup);

        // Particles - romantic dust
        const particleCount = 300;
        const particleGeo = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleSpeeds = [];

        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 15;
            particlePositions[i * 3 + 1] = Math.random() * 8;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 10 - 2;
            particleSpeeds.push({
                y: 0.002 + Math.random() * 0.005,
                x: (Math.random() - 0.5) * 0.002,
                z: (Math.random() - 0.5) * 0.002
            });
        }

        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particleMat = new THREE.PointsMaterial({
            color: 0xffb6c1,
            size: 0.08,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(particleGeo, particleMat);
        scene.add(particles);

        // Ground - subtle reflection
        const groundGeo = new THREE.PlaneGeometry(50, 50);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x0f050f,
            roughness: 0.1,
            metalness: 0.5
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // Scroll state
        let scrollProgress = 0;
        let targetScrollProgress = 0;
        const sections = document.querySelectorAll('.scene-section');

        window.addEventListener('scroll', () => {
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            targetScrollProgress = Math.max(0, Math.min(1, window.scrollY / maxScroll));
        });

        // Text animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const overlay = entry.target.querySelector('.text-overlay');
                if (entry.isIntersecting) {
                    overlay.classList.add('visible');
                } else {
                    overlay.classList.remove('visible');
                }
            });
        }, { threshold: 0.5 });

        sections.forEach(section => observer.observe(section));

        // Animation
        const clock = new THREE.Clock();
        let time = 0;

        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 2000);

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            time += delta;

            // Smooth scroll
            scrollProgress += (targetScrollProgress - scrollProgress) * 0.03;

            // Scene phases
            const phase = scrollProgress * 3; // 0 to 3

            // Character movement - approach each other
            const startDist = 3.5;
            const endDist = 0.6;
            const currentDist = THREE.MathUtils.lerp(startDist, endDist, Math.min(phase / 2.5, 1));
            
            if (tomGroup && jerryGroup) {
                tomGroup.position.x = -currentDist;
                jerryGroup.position.x = currentDist;
                
                // Rotate to face each other more as they get closer
                const baseAngle = Math.PI / 8;
                const closeAngle = Math.PI / 2.2;
                const angle = THREE.MathUtils.lerp(baseAngle, closeAngle, Math.min(phase / 2.5, 1));
                
                tomGroup.rotation.y = angle;
                jerryGroup.rotation.y = -angle;
                
                // Subtle breathing animation
                const breath = Math.sin(time * 1.5) * 0.015;
                tomGroup.position.y = breath;
                jerryGroup.position.y = Math.sin(time * 1.5 + 1) * 0.015;
                
                // Sway
                tomGroup.rotation.z = Math.sin(time * 0.5) * 0.01;
                jerryGroup.rotation.z = Math.sin(time * 0.5 + 2) * 0.01;
            }

            // Camera - dramatic movement
            const baseZ = 6;
            const closeZ = 2.5;
            const zoom = THREE.MathUtils.lerp(baseZ, closeZ, Math.min(phase / 2.5, 1));
            
            camera.position.z = zoom + Math.sin(time * 0.3) * 0.05;
            camera.position.y = 1.2 + Math.sin(time * 0.2) * 0.03;
            
            // Orbit at climax
            if (phase > 2.2) {
                const orbitProgress = (phase - 2.2) / 0.8;
                camera.position.x = Math.sin(orbitProgress * Math.PI * 0.3) * 1.5;
                camera.lookAt(0, 1.3, 0);
            } else {
                camera.position.x = Math.sin(time * 0.1) * 0.2;
                camera.lookAt(0, 1.1, 0);
            }

            // Lighting evolution
            const warmth = Math.min(phase / 2.5, 1);
            
            // Key light warms up
            keyLight.color.setHSL(0.08 + warmth * 0.02, 0.6, 0.85);
            keyLight.intensity = 80 + warmth * 60;
            
            // Rim light intensifies and shifts to pink
            rimLight.color.setHSL(0.9 - warmth * 0.1, 0.8, 0.7);
            rimLight.intensity = 60 + warmth * 100;
            
            // Fill becomes warmer
            fillLight.color.setHSL(0.7 - warmth * 0.2, 0.5, 0.6);
            fillLight.intensity = 3 + warmth * 2;

            // Bloom intensifies
            bloomPass.strength = 0.4 + warmth * 0.4;

            // Particles
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] += particleSpeeds[i].y;
                positions[i * 3] += particleSpeeds[i].x + Math.sin(time + i) * 0.001;
                
                if (positions[i * 3 + 1] > 8) {
                    positions[i * 3 + 1] = 0;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            
            // Particles gather between characters at climax
            if (phase > 1.5) {
                const gatherStrength = (phase - 1.5) / 1.5;
                particles.material.opacity = 0.6 + gatherStrength * 0.4;
                particles.material.size = 0.08 + gatherStrength * 0.05;
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
